<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title></title>
		<description>An elder's memo.</description>
		<link>/</link>
		<atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Jekyll render with pandoc on windows</title>
				<description>&lt;h2 id=&quot;下载绿色版jekyll&quot;&gt;下载绿色版Jekyll&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/sohero/PortableJekyll&quot; title=&quot;下载地址&quot;&gt;下载地址&lt;/a&gt;，这个版本，在原Portable Jekyll的基础上，修改了一下setpath.cmd。这样在写的正文里有中文也不会报错了。&lt;/li&gt;
&lt;li&gt;解压到任一目录，直接运行setpath.cmd，就可以使用了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;安装pandoc&quot;&gt;安装pandoc&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Jekyll的两个markdown解析器，对于mathjax的支持都不完美。用pandoc没有问题，不过需要安装jekyll-pandoc插件，&lt;a href=&quot;https://github.com/sohero/jekyll-pandoc&quot;&gt;插件下载地址&lt;/a&gt;。这个版本修改了一下依赖的Jekyll版本号，这样就可以在Jekyll 3.0里使用了。&lt;/li&gt;
&lt;li&gt;安装pandoc：&lt;a href=&quot;http://pandoc.org/&quot;&gt;下载地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Thu, 17 Dec 2015 00:00:00 +0800</pubDate>
				<link>/tools/log/2015/12/17/jekyll-render-with-pandoc-on-windows.html</link>
				<guid isPermaLink="true">/tools/log/2015/12/17/jekyll-render-with-pandoc-on-windows.html</guid>
			</item>
		
			<item>
				<title>git笔记 & cheatsheet</title>
				<description>&lt;p&gt;&lt;a class=&quot;btn btn-default&quot; href=&quot;https://github.com/sohero/git&quot;&gt;Go.&lt;/a&gt; &lt;a class=&quot;btn btn-default&quot; href=&quot;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Thu, 17 Dec 2015 00:00:00 +0800</pubDate>
				<link>/tools/log/2015/12/17/git-note.html</link>
				<guid isPermaLink="true">/tools/log/2015/12/17/git-note.html</guid>
			</item>
		
			<item>
				<title>Probabilistic Language Modeling</title>
				<description>&lt;ul&gt;
&lt;li&gt;Goal: compute the probability of a sentence or a sequence of words: &lt;span class=&quot;math display&quot;&gt;\[
P(W)=P(w_1,w_2,w_3,...,w_n)
\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Related task: probability of an upcoming word: &lt;span class=&quot;math display&quot;&gt;\[
p(w_5|w_1,w_2,w_3,w_4)
\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;A model that computes either of these &lt;span class=&quot;math inline&quot;&gt;\(P(W)\)&lt;/span&gt; or &lt;span class=&quot;math inline&quot;&gt;\(P(w_n|w_1,w_2,...,w_{n-1})\)&lt;/span&gt; is called a &lt;code&gt;language model&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;the-chain-rule-of-probability&quot;&gt;The Chain Rule of Probability&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[
P(A,B,C,D)=P(A)P(B|A)P(C|A,B)P(D|A,B,C)
\]&lt;/span&gt; The chain rule in general: &lt;span class=&quot;math display&quot;&gt;\[
P(x_1,x_2,x_3,…,x_n) = P(x_1)P(x_2|x_1)P(x_3|x_1,x_2)…P(x_n|x_1,…,x_{n-1})
\]&lt;/span&gt; i.e. &lt;span class=&quot;math display&quot;&gt;\[
P(w_1w_2···w_n)=\prod_i P(w_i|w_1w_2···w_{i-1})
\]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;markov-assumption&quot;&gt;Markov Assumption&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[
P(w_1w_2···w_n)\approx \prod_i P(w_i|w_{i-k}···w_{i-1})
\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unigram model &lt;span class=&quot;math display&quot;&gt;\[
P(w_1w_2···w_n)\approx \prod_i P(w_i)
\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Bigram model &lt;span class=&quot;math display&quot;&gt;\[
P(w_1w_2···w_n)\approx \prod_i P(w_i|w_{i-1})
\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;N-gram model&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Thu, 17 Dec 2015 00:00:00 +0800</pubDate>
				<link>/nlp/2015/12/17/probabilistic-language-modeling.html</link>
				<guid isPermaLink="true">/nlp/2015/12/17/probabilistic-language-modeling.html</guid>
			</item>
		
			<item>
				<title>word2vec</title>
				<description>&lt;h2 id=&quot;main-idea-of-word2vec&quot;&gt;Main idea of word2vec&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Instead of capturing cooccurrence counts directly&lt;/li&gt;
&lt;li&gt;Predict surrounding words of every word&lt;/li&gt;
&lt;li&gt;Faster and can easily incorporate a new sentence/document or add a word to the vocabulary&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;details&quot;&gt;Details&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Predict surrounding words in a window of length &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; of every word.&lt;/li&gt;
&lt;li&gt;Objective function: Maximize the &lt;span class=&quot;math inline&quot;&gt;\(log\)&lt;/span&gt; probability of any context word given the current center word: &lt;span class=&quot;math display&quot;&gt;\[
J(\theta)=\frac{1}{T} \sum_{t=1}^T \sum_{-c\leq j \leq c,j \neq 0} log p(w_{t+j}|w_t)
\]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[
p(w_{t+j}|w_t)=p(w_o|w_i)=\frac{exp(v_{w_o}&amp;#39;^T v_{w_i})}{\sum_{w=1}^W exp(v_w&amp;#39;^T v_{w_i})}
\]&lt;/span&gt; where &lt;span class=&quot;math inline&quot;&gt;\(v\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(v&amp;#39;\)&lt;/span&gt; are &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; vector representations of &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; (so every word has two vectors)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;glove&quot;&gt;GloVe&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[
J=\frac{1}{2} \sum_{ij} f(P_{ij})(w_i \cdot \tilde w_j-logP_{ij})^2
\]&lt;/span&gt;&lt;/p&gt;
</description>
				<pubDate>Mon, 14 Dec 2015 00:00:00 +0800</pubDate>
				<link>/foundation/2015/12/14/word2vec.html</link>
				<guid isPermaLink="true">/foundation/2015/12/14/word2vec.html</guid>
			</item>
		
			<item>
				<title>sense2vec - a fast and accurate method for word sense disambiguation in neural word embeddings</title>
				<description>&lt;p&gt;Despite these advancements, most word embedding techniques share a common problem in that each word must encode all of its potential meanings into a single vector.&lt;/p&gt;
&lt;p&gt;This technique is inspired by the work of Huang et al. (2012), which uses a multi-prototype neural vector-space model that clusters contexts to generate prototypes. Given a pre-trained word embedding model, each context embedding is generated by computing a weighted sum of the words in the context (weighted by tf-idf). Then, for each term, the associated context embeddings are clustered. The clusters are used to re-label each occurrence of each word in the corpus. Once these terms have been re-labeled with the cluster’s number, a new word model is trained on the labeled embeddings (with a different vector for each) generating the word-sense embeddings.&lt;/p&gt;
&lt;p&gt;We expand on the work of Huang et al. (2012) by leveraging supervised NLP labels instead of unsupervised clusters to determine a particular word nstance’s sense. This eliminates the need to train embeddings multiple times, eliminates the need for a clustering step, and creates an efficient method by which a supervised classifier may consume the appropriate word-sense embedding.&lt;/p&gt;
&lt;p&gt;Given a labeled corpus (either by hand or by a model) with one or more labels per word, the sense2vec model first counts the number of uses (where a unique word maps set of one or more labels/uses) of each word and generates a random ”sense embedding” for each use. A model is then trained using either the CBOW, Skip-gram, or Structured Skip-gram model onfigurations. Instead of predicting a token given surrounding tokens, this model predicts a word sense given surrounding senses. &lt;img src=&quot;/assets/images/16.jpg&quot; alt=&quot;sense2vec&quot; /&gt;&lt;/p&gt;
</description>
				<pubDate>Mon, 14 Dec 2015 00:00:00 +0800</pubDate>
				<link>/foundation/paper/2015/12/14/sense2vec-a-fast-and-accurate-method-for-word-sense-disambiguation-in-neural-word-embeddings.html</link>
				<guid isPermaLink="true">/foundation/paper/2015/12/14/sense2vec-a-fast-and-accurate-method-for-word-sense-disambiguation-in-neural-word-embeddings.html</guid>
			</item>
		
			<item>
				<title>End-To-End Memory Networks</title>
				<description>&lt;h2 id=&quot;single-layer&quot;&gt;Single Layer&lt;/h2&gt;
&lt;p&gt;A layer has two memroy: &lt;code&gt;input memory&lt;/code&gt;,&lt;code&gt;output memory&lt;/code&gt;. Parameters are &lt;span class=&quot;math inline&quot;&gt;\(A \in \Bbb R^{d \times |V|}\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(B \in \Bbb R^{d \times |V|}\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(C \in \Bbb R^{d \times |V|}\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(W \in \Bbb R^{|V| \times d}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Input set &lt;span class=&quot;math inline&quot;&gt;\(x_1,...,x_i\)&lt;/span&gt; (one hot encoding or distribute encoding? probably the one hot.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input memory&lt;/strong&gt; The input memory represented by &lt;span class=&quot;math inline&quot;&gt;\(\\{m_i\\}\)&lt;/span&gt;, the &lt;span class=&quot;math inline&quot;&gt;\(m_i\)&lt;/span&gt; is computed by &lt;span class=&quot;math inline&quot;&gt;\(Ax_i\)&lt;/span&gt;, i.e. each &lt;span class=&quot;math inline&quot;&gt;\(m_i\)&lt;/span&gt; is transformed from &lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt; using &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Query&lt;/strong&gt; The query &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; is transformed to the internal state &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; using &lt;span class=&quot;math inline&quot;&gt;\(Bq\)&lt;/span&gt;. Then, compute the match probability &lt;span class=&quot;math inline&quot;&gt;\(p_i\)&lt;/span&gt; between &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; and each memory &lt;span class=&quot;math inline&quot;&gt;\(m_i\)&lt;/span&gt; using softmax: &lt;span class=&quot;math display&quot;&gt;\[
p_i=softmax(u^Tm_i)
\]&lt;/span&gt; so &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; is a probability vecotr over the inputs.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output memory&lt;/strong&gt; Each &lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt; is transformed to a output vecotr &lt;span class=&quot;math inline&quot;&gt;\(c_i\)&lt;/span&gt; by &lt;span class=&quot;math inline&quot;&gt;\(Cx_i\)&lt;/span&gt;. The response vector &lt;span class=&quot;math inline&quot;&gt;\(o\)&lt;/span&gt; from the memory computed by: &lt;span class=&quot;math display&quot;&gt;\[
o=\sum_{i} p_ic_i
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Generating final prediction&lt;/strong&gt; The predicted label formula: &lt;span class=&quot;math display&quot;&gt;\[
\hat a=softmax(W(o+u))
\]&lt;/span&gt; &lt;img src=&quot;/assets/images/15.jpg&quot; alt=&quot;Figure 1&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;mutltiple-layers&quot;&gt;Mutltiple Layers&lt;/h2&gt;
&lt;p&gt;With &lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt; hop operations, the memory layers are stacked in the following way:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The input tot layers above the first is the sum of the output &lt;span class=&quot;math inline&quot;&gt;\(o^k\)&lt;/span&gt; and the input &lt;span class=&quot;math inline&quot;&gt;\(u^k\)&lt;/span&gt; from layers &lt;span class=&quot;math inline&quot;&gt;\(k-1\)&lt;/span&gt;(different ways to combine &lt;span class=&quot;math inline&quot;&gt;\(o^k\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(u^k\)&lt;/span&gt; are proposed later): &lt;span class=&quot;math display&quot;&gt;\[
u^{k+1}=u^k+o^k
\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Each layer has its own embedding matrices &lt;span class=&quot;math inline&quot;&gt;\(A^k\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(C^k\)&lt;/span&gt;, used to embed the inputs &lt;span class=&quot;math inline&quot;&gt;\(\\{x_i\\}\)&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;At the top of network, the input &lt;span class=&quot;math inline&quot;&gt;\(W\)&lt;/span&gt; also combines the input and the output of the top memory layer:&lt;span class=&quot;math inline&quot;&gt;\(\hat a=softmax(Wu^{k+1})=softmax(W(o^K+u^K))\)&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Two types of weights tying:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Adjacent&lt;/strong&gt;: the output embedding for one layer is the input embedding for the one above, i.e. &lt;span class=&quot;math inline&quot;&gt;\(A^{k+1}=C^k\)&lt;/span&gt;. also constrain (a) the answer prediction matrix to be the same as the final output embedding, i.e. &lt;span class=&quot;math inline&quot;&gt;\(W^T=C^K\)&lt;/span&gt;, and (b) the question embedding to match the input embedding of the first layer, i.e. &lt;span class=&quot;math inline&quot;&gt;\(B=A^1\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Layer-wise (RNN-like)&lt;/strong&gt;: the input and output embeddings are the same across different layers, i.e. &lt;span class=&quot;math inline&quot;&gt;\(A^1=A^2=...=A^K\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(C^1=C^2=...=C^K\)&lt;/span&gt;. found it useful to add a linear mapping &lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt; to the update of &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; between hops; that is, &lt;span class=&quot;math inline&quot;&gt;\(u^{k+1}=Hu^k+o^k\)&lt;/span&gt;. This mapping is learned from data and used throughout experiments for layer-wise weight tying.&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Mon, 14 Dec 2015 00:00:00 +0800</pubDate>
				<link>/foundation/paper/2015/12/14/end-to-end-memory-networks.html</link>
				<guid isPermaLink="true">/foundation/paper/2015/12/14/end-to-end-memory-networks.html</guid>
			</item>
		
			<item>
				<title>Edit Distance</title>
				<description>&lt;p&gt;The minimum edit distance between two strings is the minimum number of editing operations &lt;code&gt;Insertion&lt;/code&gt; &lt;code&gt;Deletion&lt;/code&gt; &lt;code&gt;Substitution&lt;/code&gt; needed to transform one into other.&lt;/p&gt;
&lt;h2 id=&quot;defining-min-edit-distance&quot;&gt;Defining Min Edit Distance&lt;/h2&gt;
&lt;p&gt;For two Strings:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; of length &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt; of length &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We define &lt;span class=&quot;math inline&quot;&gt;\(D(i,j)\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the edit distance between &lt;span class=&quot;math inline&quot;&gt;\(X[1..i]\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(Y[1..j]\)&lt;/span&gt;, i.e. the first &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; characters of &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; and the first &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; characters of &lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;the edit distance between &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt; is thus &lt;span class=&quot;math inline&quot;&gt;\(D(n,m)\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;computing-min-edit-distance-levenshtein&quot;&gt;Computing Min Edit Distance (Levenshtein)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Initialization &lt;span class=&quot;math inline&quot;&gt;\(D(i,0)=i\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(D(0,j)=j\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Recurrence Relation: for each i=i…M&lt;/p&gt;
&lt;p&gt;for each j=1…N &lt;span class=&quot;math display&quot;&gt;\[
D(i,j)=
\begin{cases}
D(i-1,j)+1 \\
D(i, j-1)+1 \\
D(i-1, j-1) + 
\begin{cases}
2 &amp;amp; \text{if $X(i) \neq Y(j)$}\\
0 &amp;amp;\text{if $X(i) = Y(j)$}
\end{cases} 
\end{cases}
\]&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Termination: &lt;span class=&quot;math inline&quot;&gt;\(D(N,M)\)&lt;/span&gt; is the distance. &lt;img src=&quot;/assets/images/17.jpg&quot; alt=&quot;edit distance table&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Mon, 14 Dec 2015 00:00:00 +0800</pubDate>
				<link>/foundation/nlp/2015/12/14/edit-distance.html</link>
				<guid isPermaLink="true">/foundation/nlp/2015/12/14/edit-distance.html</guid>
			</item>
		
			<item>
				<title>the equations of backpropagation</title>
				<description>&lt;p&gt;Typically, the last layer error vector: &lt;span class=&quot;math display&quot;&gt;\[
\delta ^L = \nabla C \odot \sigma &amp;#39;(z^L)
= a-y
\]&lt;/span&gt; The middle &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt; hidden layer error vector: &lt;span class=&quot;math display&quot;&gt;\[
\delta ^l = (W^{l+1})^T\delta ^{l+1}\odot \sigma &amp;#39;(z^l)
\]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[
\frac{\partial C}{\partial b^l}=\delta ^l
\]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[
\frac{\partial C}{\partial W^l}=\delta ^l (a^{l-1})^T
\]&lt;/span&gt; Here, &lt;span class=&quot;math inline&quot;&gt;\(W^l \in \Bbb R^{|l|\times|l-1|}\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(b^l\in \Bbb R^{|l|\times 1}\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(z^l\in \Bbb R^{|l|\times 1}\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(a^l\in \Bbb R^{|l|\times 1}\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(\delta^l\in \Bbb R^{|l|\times 1}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/13.jpg&quot; alt=&quot;&quot; /&gt; &lt;img src=&quot;/assets/images/14.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
				<pubDate>Mon, 07 Dec 2015 00:00:00 +0800</pubDate>
				<link>/foundation/2015/12/07/the-equations-of-backpropagation.html</link>
				<guid isPermaLink="true">/foundation/2015/12/07/the-equations-of-backpropagation.html</guid>
			</item>
		
			<item>
				<title>Rectified Linear Unit (ReLU)</title>
				<description>&lt;figure&gt;
&lt;img src=&quot;/assets/images/10.jpg&quot; alt=&quot;ReLU&quot; /&gt;&lt;figcaption&gt;ReLU&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;The Rectified Linear Unit (ReLU) computes the function &lt;span class=&quot;math inline&quot;&gt;\(f(x)=max(0,x)\)&lt;/span&gt;, which is simply thresholded at zero.&lt;/p&gt;
&lt;p&gt;There are several pros and cons to using the ReLUs:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;(Pros) Compared to sigmoid/tanh neurons that involve expensive operations (exponentials, etc.), the ReLU can be implemented by simply thresholding a matrix of activations at zero. Meanwhile, ReLUs does not suffer from saturating.&lt;/li&gt;
&lt;li&gt;(Pros) It was found to greatly accelerate the convergence of stochastic gradient descent compared to the sigmoid/tanh functions. It is argued that this is due to its linear, non-saturating form.&lt;/li&gt;
&lt;li&gt;(Cons) Unfortunately, ReLU units can be fragile during training and can “die”. For example, a large gradient flowing through a ReLU neuron could cause the weights to update in such a way that the neuron will never activate on any datapoint again. If this happens, then the gradient flowing through the unit will forever be zero from that point on. That is, the ReLU units can irreversibly die during training since they can get knocked off the data manifold. For example, you may find that as much as 40% of your network can be “dead” (i.e., neurons that never activate across the entire training dataset) if the learning rate is set too high. With a proper setting of the learning rate this is less frequently an issue.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;leaky-relu&quot;&gt;Leaky ReLU&lt;/h2&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/images/11.jpg&quot; alt=&quot;Leaky ReLU&quot; /&gt;&lt;figcaption&gt;Leaky ReLU&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Leaky ReLUs are one attempt to fix the “dying ReLU” problem. Instead of the function being zero when &lt;span class=&quot;math inline&quot;&gt;\(x&amp;lt;0\)&lt;/span&gt;, a leaky ReLU will instead have a small negative slope(of 0.01, or so). That is, the function computes &lt;span class=&quot;math inline&quot;&gt;\(f(x)=ax\)&lt;/span&gt; if &lt;span class=&quot;math inline&quot;&gt;\(x&amp;lt;0\)&lt;/span&gt; and &lt;span class=&quot;math inline&quot;&gt;\(f(x)=x\)&lt;/span&gt; if &lt;span class=&quot;math inline&quot;&gt;\(x\geqslant 0\)&lt;/span&gt;, where &lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt; is a small constant. Some people report success with this form of activation function, but the results are not always consistent.&lt;/p&gt;
&lt;h2 id=&quot;parametric-relu&quot;&gt;Parametric ReLU&lt;/h2&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/images/12.jpg&quot; alt=&quot;rectified unit family&quot; /&gt;&lt;figcaption&gt;rectified unit family&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;The first variant is called parametric rectified linear unit (PReLU). In PReLU, the slopes of negative part are learned from data rather than pre-defined.&lt;/p&gt;
&lt;h2 id=&quot;randomized-relu&quot;&gt;Randomized ReLU&lt;/h2&gt;
&lt;p&gt;In RReLU, the slopes of negative parts are randomized in a given range in the training, and then fixed in the testing. As mentioned in [B. Xu, N. Wang, T. Chen, and M. Li. Empirical Evaluation of Rectified Activations in Convolution Network. In ICML Deep Learning Workshop, 2015.], in a recent Kaggle National Data Science Bowl (NDSB) competition, it is reported that RReLU could reduce overfitting due to its randomized nature. Moreover, suggested by the NDSB competition winner, the random &lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt; in training is sampled from &lt;span class=&quot;math inline&quot;&gt;\(1/U(3,8)\)&lt;/span&gt; and in test time it is fixed as its expectation, i.e., &lt;span class=&quot;math inline&quot;&gt;\(2/(l+u)=2/11\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;In conclusion, three types of ReLU variants all consistently outperform the original ReLU in these three data sets. And PReLU and RReLU seem better choices.&lt;/strong&gt;&lt;/p&gt;
</description>
				<pubDate>Wed, 18 Nov 2015 00:00:00 +0800</pubDate>
				<link>/foundation/2015/11/18/rectified-linear-unit-relu.html</link>
				<guid isPermaLink="true">/foundation/2015/11/18/rectified-linear-unit-relu.html</guid>
			</item>
		
			<item>
				<title>正则表达式</title>
				<description>&lt;table cellspacing=&quot;0&quot; style=&quot;margin:auto; border-style:solid; border-width:1px 1px 0px 0px; color:rgb(0,0,0); font-family:Simsun; font-size:16px; background:rgb(238,238,238)&quot;&gt;
	&lt;caption style=&quot;margin:auto; font-weight:bold&quot;&gt;表1.常用的元字符&lt;/caption&gt;
	&lt;thead&gt;
		&lt;tr&gt;
			&lt;th scope=&quot;col&quot; style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				代码
			&lt;/th&gt;
			&lt;th scope=&quot;col&quot; style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				说明
			&lt;/th&gt;
		&lt;/tr&gt;
	&lt;/thead&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;.&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配除换行符以外的任意字符&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\w&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配字母或数字或下划线或汉字&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\s&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\d&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配数字&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\b&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配单词的开始或结束&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;^&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配字符串的开始&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;$&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配字符串的结束&lt;br /&gt;
				&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
	&lt;br /&gt;
	
&lt;/p&gt;
&lt;p&gt;
	&lt;table cellspacing=&quot;0&quot; style=&quot;margin:auto; border-style:solid; border-width:1px 1px 0px 0px; color:rgb(0,0,0); font-family:Simsun; font-size:16px; background:rgb(238,238,238)&quot;&gt;
		&lt;caption style=&quot;margin:auto; font-weight:bold&quot;&gt;表2.常用的限定符&lt;/caption&gt;
		&lt;thead&gt;
			&lt;tr&gt;
				&lt;th scope=&quot;col&quot; style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					代码/语法
				&lt;/th&gt;
				&lt;th scope=&quot;col&quot; style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					说明
				&lt;/th&gt;
			&lt;/tr&gt;
		&lt;/thead&gt;
		&lt;tbody&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;*&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;重复零次或更多次&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;+&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;重复一次或更多次&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;?&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;重复零次或一次&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;{n}&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;重复n次&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;{n,}&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;重复n次或更多次&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;{n,m}&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;重复n到m次&lt;br /&gt;
					&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
		&lt;/tbody&gt;
	&lt;/table&gt;
	&lt;br /&gt;
	
&lt;/p&gt;
&lt;p&gt;
	&lt;table cellspacing=&quot;0&quot; style=&quot;margin:auto; border-style:solid; border-width:1px 1px 0px 0px; color:rgb(0,0,0); font-family:Simsun; font-size:16px; background:rgb(238,238,238)&quot;&gt;
		&lt;caption style=&quot;margin:auto; font-weight:bold&quot;&gt;表3.常用的反义代码&lt;/caption&gt;
		&lt;thead&gt;
			&lt;tr&gt;
				&lt;th scope=&quot;col&quot; style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					代码/语法
				&lt;/th&gt;
				&lt;th scope=&quot;col&quot; style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					说明
				&lt;/th&gt;
			&lt;/tr&gt;
		&lt;/thead&gt;
		&lt;tbody&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\W&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配任意不是字母，数字，下划线，汉字的字符&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\S&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配任意不是空白符的字符&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\D&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配任意非数字的字符&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\B&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配不是单词开头或结束的位置&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;[^x]&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配除了x以外的任意字符&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;[^aeiou]&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配除了aeiou这几个字母以外的任意字符&lt;br /&gt;
					&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
		&lt;/tbody&gt;
	&lt;/table&gt;
&lt;/p&gt;
&lt;p&gt;
	&lt;br /&gt;
	
&lt;/p&gt;
&lt;p&gt;
	&lt;table cellspacing=&quot;0&quot; style=&quot;margin:auto; border-style:solid; border-width:1px 1px 0px 0px; color:rgb(0,0,0); font-family:Simsun; font-size:16px; background:rgb(238,238,238)&quot;&gt;
		&lt;caption style=&quot;margin:auto; font-weight:bold&quot;&gt;表4.常用分组语法&lt;/caption&gt;
		&lt;tbody&gt;
			&lt;tr&gt;
				&lt;th scope=&quot;col&quot; style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					分类
				&lt;/th&gt;
				&lt;th scope=&quot;col&quot; style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					代码/语法
				&lt;/th&gt;
				&lt;th scope=&quot;col&quot; style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					说明
				&lt;/th&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;th rowspan=&quot;3&quot; style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					捕获
				&lt;/th&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(exp)&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配exp,并捕获文本到自动命名的组里&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?&amp;lt;name&amp;gt;exp)&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配exp,并捕获文本到名称为name的组里，也可以写成(?&#39;name&#39;exp)&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?:exp)&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配exp,不捕获匹配的文本，也不给此分组分配组号&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;th rowspan=&quot;4&quot; style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					零宽断言
				&lt;/th&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?=exp)&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配exp前面的位置&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?&amp;lt;=exp)&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配exp后面的位置&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?!exp)&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配后面跟的不是exp的位置&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?&amp;lt;!exp)&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;匹配前面不是exp的位置&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;th rowspan=&quot;1&quot; style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					注释
				&lt;/th&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?#comment)&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读&lt;br /&gt;
					&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
		&lt;/tbody&gt;
	&lt;/table&gt;
	&lt;br /&gt;
	
	&lt;table cellspacing=&quot;0&quot; style=&quot;margin:auto; border-style:solid; border-width:1px 1px 0px 0px; color:rgb(0,0,0); font-family:Simsun; font-size:16px; background:rgb(238,238,238)&quot;&gt;
		&lt;caption style=&quot;margin:auto; font-weight:bold&quot;&gt;表5.懒惰限定符&lt;/caption&gt;
		&lt;thead&gt;
			&lt;tr&gt;
				&lt;th scope=&quot;col&quot; style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					代码/语法
				&lt;/th&gt;
				&lt;th scope=&quot;col&quot; style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					说明
				&lt;/th&gt;
			&lt;/tr&gt;
		&lt;/thead&gt;
		&lt;tbody&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;*?&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;重复任意次，但尽可能少重复&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;+?&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;重复1次或更多次，但尽可能少重复&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;??&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;重复0次或1次，但尽可能少重复&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;{n,m}?&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;重复n到m次，但尽可能少重复&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;{n,}?&lt;/span&gt;
				&lt;/td&gt;
				&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
					&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;重复n次以上，但尽可能少重复&lt;/span&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
		&lt;/tbody&gt;
	&lt;/table&gt;
	&lt;br /&gt;
	
&lt;/p&gt;
&lt;p&gt;
&lt;/p&gt;
&lt;h2 id=&quot;lookaround&quot; style=&quot;border-bottom-style:solid; border-bottom-width:1px; border-bottom-color:gray; border-right-style:solid; border-right-width:1px; border-right-color:gray; clear:both; font-family:Simsun; background-color:rgb(238,238,238)&quot;&gt;
	零宽断言
&lt;/h2&gt;
&lt;p&gt;
&lt;/p&gt;
&lt;p style=&quot;text-indent:2em; line-height:22.4px; margin:5px 20px; font-family:Simsun; font-size:16px&quot;&gt;
	接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\b&lt;/span&gt;,&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;^&lt;/span&gt;,&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;$&lt;/span&gt;那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为&lt;span class=&quot;name&quot; style=&quot;margin:3px; font-weight:bold&quot;&gt;零宽断言&lt;/span&gt;。最好还是拿例子来说明吧：
&lt;/p&gt;
&lt;p style=&quot;text-indent:2em; line-height:22.4px; margin:5px 20px; font-family:Simsun; font-size:16px&quot;&gt;
	&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?=exp)&lt;/span&gt;也叫&lt;span class=&quot;name&quot; style=&quot;margin:3px; font-weight:bold&quot;&gt;零宽度正预测先行断言&lt;/span&gt;，它&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;断言自身出现的位置的后面能匹配表达式exp&lt;/span&gt;。比如&lt;span class=&quot;regex&quot; style=&quot;margin:3px; color:red&quot;&gt;\b\w+(?=ing\b)&lt;/span&gt;，匹配&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;以ing结尾的单词的前面部分(除了ing以外的部分)&lt;/span&gt;，如查找&lt;span class=&quot;string&quot; style=&quot;margin:3px; font-style:italic&quot;&gt;I&#39;m singing while you&#39;re dancing.&lt;/span&gt;时，它会匹配&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;sing&lt;/span&gt;和&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;danc&lt;/span&gt;。
&lt;/p&gt;
&lt;p style=&quot;text-indent:2em; line-height:22.4px; margin:5px 20px; font-family:Simsun; font-size:16px&quot;&gt;
	&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?&amp;lt;=exp)&lt;/span&gt;也叫&lt;span class=&quot;name&quot; style=&quot;margin:3px; font-weight:bold&quot;&gt;零宽度正回顾后发断言&lt;/span&gt;，它&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;断言自身出现的位置的前面能匹配表达式exp&lt;/span&gt;。比如&lt;span class=&quot;regex&quot; style=&quot;margin:3px; color:red&quot;&gt;(?&amp;lt;=\bre)\w+\b&lt;/span&gt;会匹配&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;以re开头的单词的后半部分(除了re以外的部分)&lt;/span&gt;，例如在查找&lt;span class=&quot;string&quot; style=&quot;margin:3px; font-style:italic&quot;&gt;reading a book&lt;/span&gt;时，它匹配&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;ading&lt;/span&gt;。
&lt;/p&gt;
&lt;h2 id=&quot;negativelookaround&quot; style=&quot;border-bottom-style:solid; border-bottom-width:1px; border-bottom-color:gray; border-right-style:solid; border-right-width:1px; border-right-color:gray; clear:both; font-family:Simsun; background-color:rgb(238,238,238)&quot;&gt;
	负向零宽断言
&lt;/h2&gt;
&lt;p style=&quot;text-indent:2em; line-height:22.4px; margin:5px 20px; font-family:Simsun; font-size:16px&quot;&gt;
	前面我们提到过怎么查找&lt;strong&gt;不是某个字符或不在某个字符类里&lt;/strong&gt;的字符的方法(反义)。但是如果我们只是想要&lt;strong&gt;确保某个字符没有出现，但并不想去匹配它&lt;/strong&gt;时怎么办？例如，如果我们想查找这样的单词--它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：
&lt;/p&gt;
&lt;p style=&quot;text-indent:2em; line-height:22.4px; margin:5px 20px; font-family:Simsun; font-size:16px&quot;&gt;
	&lt;span class=&quot;regex&quot; style=&quot;margin:3px; color:red&quot;&gt;\b\w*q[^u]\w*\b&lt;/span&gt;匹配&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;包含&lt;strong&gt;后面不是字母u的字母q&lt;/strong&gt;的单词&lt;/span&gt;。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像&lt;strong&gt;Iraq&lt;/strong&gt;,&lt;strong&gt;Benq&lt;/strong&gt;，这个表达式就会出错。这是因为&lt;span class=&quot;part&quot; style=&quot;margin:3px; color:green&quot;&gt;[^u]&lt;/span&gt;总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的&lt;span class=&quot;part&quot; style=&quot;margin:3px; color:green&quot;&gt;[^u]&lt;/span&gt;将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的&lt;span class=&quot;part&quot; style=&quot;margin:3px; color:green&quot;&gt;\w*\b&lt;/span&gt;将会匹配下一个单词，于是&lt;span class=&quot;regex&quot; style=&quot;margin:3px; color:red&quot;&gt;\b\w*q[^u]\w*\b&lt;/span&gt;就能匹配整个&lt;span class=&quot;string&quot; style=&quot;margin:3px; font-style:italic&quot;&gt;Iraq fighting&lt;/span&gt;。&lt;span class=&quot;name&quot; style=&quot;margin:3px; font-weight:bold&quot;&gt;负向零宽断言&lt;/span&gt;能解决这样的问题，因为它只匹配一个位置，并不&lt;strong&gt;消费&lt;/strong&gt;任何字符。现在，我们可以这样来解决这个问题：&lt;span class=&quot;regex&quot; style=&quot;margin:3px; color:red&quot;&gt;\b\w*q(?!u)\w*\b&lt;/span&gt;。
&lt;/p&gt;
&lt;p style=&quot;text-indent:2em; line-height:22.4px; margin:5px 20px; font-family:Simsun; font-size:16px&quot;&gt;
	&lt;span class=&quot;name&quot; style=&quot;margin:3px; font-weight:bold&quot;&gt;零宽度负预测先行断言&lt;/span&gt;&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?!exp)&lt;/span&gt;，&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;断言此位置的后面不能匹配表达式exp&lt;/span&gt;。例如：&lt;span class=&quot;regex&quot; style=&quot;margin:3px; color:red&quot;&gt;\d{3}(?!\d)&lt;/span&gt;匹配&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;三位数字，而且这三位数字的后面不能是数字&lt;/span&gt;；&lt;span class=&quot;regex&quot; style=&quot;margin:3px; color:red&quot;&gt;\b((?!abc)\w)+\b&lt;/span&gt;匹配&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;不包含连续字符串abc的单词&lt;/span&gt;。
&lt;/p&gt;
&lt;p style=&quot;text-indent:2em; line-height:22.4px; margin:5px 20px; font-family:Simsun; font-size:16px&quot;&gt;
	同理，我们可以用&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?&amp;lt;!exp)&lt;/span&gt;,&lt;span class=&quot;name&quot; style=&quot;margin:3px; font-weight:bold&quot;&gt;零宽度负回顾后发断言&lt;/span&gt;来&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;断言此位置的前面不能匹配表达式exp&lt;/span&gt;：&lt;span class=&quot;regex&quot; style=&quot;margin:3px; color:red&quot;&gt;(?&amp;lt;![a-z])\d{7}&lt;/span&gt;匹配&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;前面不是小写字母的七位数字&lt;/span&gt;。
&lt;/p&gt;
&lt;p style=&quot;text-indent:2em; line-height:22.4px; margin:5px 20px; font-family:Simsun; font-size:16px&quot;&gt;
	一个更复杂的例子：&lt;span class=&quot;regex&quot; style=&quot;margin:3px; color:red&quot;&gt;(?&amp;lt;=&amp;lt;(\w+)&amp;gt;).*(?=&amp;lt;\/\1&amp;gt;)&lt;/span&gt;匹配&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;不包含属性的简单HTML标签内里的内容&lt;/span&gt;。&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?&amp;lt;=&amp;lt;(\w+)&amp;gt;)&lt;/span&gt;指定了这样的&lt;span class=&quot;name&quot; style=&quot;margin:3px; font-weight:bold&quot;&gt;前缀&lt;/span&gt;：&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;被尖括号括起来的单词&lt;/span&gt;(比如可能是&amp;lt;b&amp;gt;)，然后是&lt;span class=&quot;part&quot; style=&quot;margin:3px; color:green&quot;&gt;.*&lt;/span&gt;(任意的字符串),最后是一个&lt;span class=&quot;name&quot; style=&quot;margin:3px; font-weight:bold&quot;&gt;后缀&lt;/span&gt;&lt;span class=&quot;part&quot; style=&quot;margin:3px; color:green&quot;&gt;(?=&amp;lt;\/\1&amp;gt;)&lt;/span&gt;。注意后缀里的&lt;span class=&quot;part&quot; style=&quot;margin:3px; color:green&quot;&gt;\/&lt;/span&gt;，它用到了前面提过的字符转义；&lt;span class=&quot;part&quot; style=&quot;margin:3px; color:green&quot;&gt;\1&lt;/span&gt;则是一个反向引用，引用的正是&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;捕获的第一组&lt;/span&gt;，前面的&lt;span class=&quot;part&quot; style=&quot;margin:3px; color:green&quot;&gt;(\w+)&lt;/span&gt;匹配的内容，这样如果前缀实际上是&amp;lt;b&amp;gt;的话，后缀就是&amp;lt;/b&amp;gt;了。整个表达式匹配的是&amp;lt;b&amp;gt;和&amp;lt;/b&amp;gt;之间的内容(再次提醒，不包括前缀和后缀本身)。
&lt;/p&gt;
&lt;p style=&quot;text-indent:2em; line-height:22.4px; margin:5px 20px; font-family:Simsun; font-size:16px&quot;&gt;
&lt;/p&gt;
&lt;h2 id=&quot;balancedgroup&quot; style=&quot;border-bottom-style:solid; border-bottom-width:1px; border-bottom-color:gray; border-right-style:solid; border-right-width:1px; border-right-color:gray; clear:both; font-family:Simsun; background-color:rgb(238,238,238)&quot;&gt;
	平衡组/递归匹配
&lt;/h2&gt;
&lt;p&gt;
&lt;/p&gt;
&lt;p style=&quot;text-indent:2em; line-height:22.4px; margin:5px 20px; font-family:Simsun; font-size:16px&quot;&gt;
	有时我们需要匹配像&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构&lt;/span&gt;，这时简单地使用&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\(.+\)&lt;/span&gt;则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如&lt;span class=&quot;string&quot; style=&quot;margin:3px; font-style:italic&quot;&gt;( 5 / ( 3 + 2 ) ) )&lt;/span&gt;，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？
&lt;/p&gt;
&lt;p style=&quot;text-indent:2em; line-height:22.4px; margin:5px 20px; font-family:Simsun; font-size:16px&quot;&gt;
	为了避免&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(&lt;/span&gt;和&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\(&lt;/span&gt;把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把&lt;span class=&quot;string&quot; style=&quot;margin:3px; font-style:italic&quot;&gt;xx &amp;lt;aa &amp;lt;bbb&amp;gt; &amp;lt;bbb&amp;gt; aa&amp;gt; yy&lt;/span&gt;这样的字符串里，最长的配对的尖括号内的内容捕获出来？
&lt;/p&gt;
&lt;p style=&quot;text-indent:2em; line-height:22.4px; margin:5px 20px; font-family:Simsun; font-size:16px&quot;&gt;
	这里需要用到以下的语法构造：
&lt;/p&gt;
&lt;ul style=&quot;font-family:Simsun; font-size:16px&quot;&gt;
	&lt;li&gt;
		&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?&#39;group&#39;)&lt;/span&gt;&amp;nbsp;把捕获的内容命名为group,并压入&lt;span class=&quot;name&quot; style=&quot;margin:3px; font-weight:bold&quot;&gt;堆栈(Stack)&lt;/span&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?&#39;-group&#39;)&lt;/span&gt;&amp;nbsp;从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败
	&lt;/li&gt;
	&lt;li&gt;
		&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?(group)yes|no)&lt;/span&gt;&amp;nbsp;如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分
	&lt;/li&gt;
	&lt;li&gt;
		&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?!)&lt;/span&gt;&amp;nbsp;零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&quot;text-indent:2em; line-height:22.4px; margin:5px 20px; font-family:Simsun; font-size:16px&quot;&gt;
	我们需要做的是每碰到了左括号，就在压入一个&amp;quot;Open&amp;quot;,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。
&lt;/p&gt;
&lt;pre class=&quot;regex&quot; style=&quot;color:red&quot;&gt;&amp;lt;                         #最外层的左括号
    [^&amp;lt;&amp;gt;]*                #最外层的左括号后面的不是括号的内容
    (
        (
            (?&#39;Open&#39;&amp;lt;)    #碰到了左括号，在黑板上写一个&amp;quot;Open&amp;quot;
            [^&amp;lt;&amp;gt;]*       #匹配左括号后面的不是括号的内容
        )+
        (
            (?&#39;-Open&#39;&amp;gt;)   #碰到了右括号，擦掉一个&amp;quot;Open&amp;quot;
            [^&amp;lt;&amp;gt;]*        #匹配右括号后面不是括号的内容
        )+
    )*
    (?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的&amp;quot;Open&amp;quot;；如果还有，则匹配失败

&amp;gt;                         #最外层的右括号&lt;/pre&gt;
&lt;p style=&quot;text-indent:2em; line-height:22.4px; margin:5px 20px; font-family:Simsun; font-size:16px&quot;&gt;
	平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;嵌套的&amp;lt;div&amp;gt;标签&lt;/span&gt;：&lt;span class=&quot;regex&quot; style=&quot;margin:3px; color:red&quot;&gt;&amp;lt;div[^&amp;gt;]*&amp;gt;[^&amp;lt;&amp;gt;]*(((?&#39;Open&#39;&amp;lt;div[^&amp;gt;]*&amp;gt;)[^&amp;lt;&amp;gt;]*)+((?&#39;-Open&#39;&amp;lt;/div&amp;gt;)[^&amp;lt;&amp;gt;]*)+)*(?(Open)(?!))&amp;lt;/div&amp;gt;&lt;/span&gt;.
&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; style=&quot;margin:auto; border-style:solid; border-width:1px 1px 0px 0px; color:rgb(0,0,0); font-family:Simsun; font-size:16px; background:rgb(238,238,238)&quot;&gt;
	&lt;caption style=&quot;margin:auto; font-weight:bold&quot;&gt;表7.尚未详细讨论的语法&lt;/caption&gt;
	&lt;thead&gt;
		&lt;tr&gt;
			&lt;th scope=&quot;col&quot; style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				代码/语法
			&lt;/th&gt;
			&lt;th scope=&quot;col&quot; style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				说明
			&lt;/th&gt;
		&lt;/tr&gt;
	&lt;/thead&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\a&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;报警字符(打印它的效果是电脑嘀一声)&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\b&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;通常是单词分界位置，但如果在字符类里使用代表退格&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\t&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;制表符，Tab&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\r&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;回车&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\v&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;竖向制表符&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\f&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;换页符&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\n&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;换行符&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\e&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;Escape&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\0nn&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;ASCII代码中八进制代码为nn的字符&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\xnn&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;ASCII代码中十六进制代码为nn的字符&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\unnnn&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;Unicode代码中十六进制代码为nnnn的字符&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\cN&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;ASCII控制字符。比如\cC代表Ctrl+C&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\A&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;字符串开头(类似^，但不受处理多行选项的影响)&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\Z&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;字符串结尾或行尾(不受处理多行选项的影响)&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\z&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;字符串结尾(类似$，但不受处理多行选项的影响)&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\G&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;当前搜索的开头&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;\p{name}&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;Unicode中命名为name的字符类，例如\p{IsGreek}&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?&amp;gt;exp)&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;贪婪子表达式&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?&amp;lt;x&amp;gt;-&amp;lt;y&amp;gt;exp)&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;平衡组&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?im-nsx:exp)&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;在子表达式exp中改变处理选项&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?im-nsx)&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;为表达式后面的部分改变处理选项&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?(exp)yes|no)&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?(exp)yes)&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;同上，只是使用空表达式作为no&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?(name)yes|no)&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;code&quot; style=&quot;margin:3px; color:blue&quot;&gt;(?(name)yes)&lt;/span&gt;
			&lt;/td&gt;
			&lt;td style=&quot;border-style:solid; border-width:0px 0px 1px 1px; border-color:gray&quot;&gt;
				&lt;span class=&quot;desc&quot; style=&quot;margin:3px; text-decoration:underline&quot;&gt;同上，只是使用空表达式作为no&lt;/span&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
&lt;br /&gt;</description>
				<pubDate>Fri, 13 Nov 2015 00:00:00 +0800</pubDate>
				<link>/tools/2015/11/13/regular-expression.html</link>
				<guid isPermaLink="true">/tools/2015/11/13/regular-expression.html</guid>
			</item>
		
	</channel>
</rss>
